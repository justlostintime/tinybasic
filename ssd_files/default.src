;.  ORIGINAL TINY BASIC INTERMEDIATE INTERPRETER
;.
;.  EXECUTIVE INITIALIZATION
;.
;:STRT PC ":Q^"        COLON, X-ON
;
;      GL
;      SB
;      BE L0           BRANCH IF NOT EMPTY
;      BR STRT         TRY AGAIN IF NULL LINE
;:L0   BN STMT         TEST FOR LINE NUMBER
;      IL              IF SO, INSERT INTO PROGRAM
;      BR STRT         GO GET NEXT
;:XEC  SB              SAVE POINTERS FOR RUN WITH
;      RB                CONCATENATED INPUT
;      XQ
;.
;.  STATEMENT EXECUTOR
;.
;:STMT BC GOTO "LET"
;
;      BV *            MUST BE A VARIABLE NAME
;      BC * "="
;:LET  JS EXPR         GO GET EXPRESSION
;      BE *            IF STATEMENT END,
;      SV                STORE RESULT
;      NX
;.
;:GOTO BC PRNT "GO"
;
;      BC GOSB "TO"
;
;      JS EXPR         GET LINE NUMBER
;      BE *
;      SB              (DO THIS FOR STARTING)
;      RB
;      GO              GO THERE
;.
;:GOSB BC * "SUB"      NO OTHER WORD BEGINS "GO..."
;
;      JS EXPR
;      BE *
;      GS
;      GO
;.
;:PRNT BC SKIP "PR"
;
;      BC P0 "INT"     OPTIONALLY OMIT "INT"
;
;:P0   BE P3
;      BR P6           IF DONE, GO TO END
;"
;:P2   BE P3
; OR ,
;:P3   BC P7 '"'
;      PQ              QUOTE MARKS STRING
;      BR P1           GO CHECK DELIMITER
;:SKIP BR IF           (ON THE WAY THRU)
;:P4   BC P5 ","
;      PT              COMMA SPACING
;      BR P2
;:P5   BC P6 ":"
;      PC "S^"         OUTPUT X-OFF
;:P6   BE *
;      NL              THEN CRLF
;      NX
;:P7   JS EXPR         TRY FOR AN EXPRESSION
;      PN
;      BR P1
;.
;:IF   BC INPT "IF"
;
;      JS EXPR
;      JS RELO
;      JS EXPR
;      BC I1 "THEN"    OPTIONAL NOISEWORD
;
;:I1   CP              COMPARE SKIPS NEXT IF TRUE
;      NX              FALSE.
;      J STMT          TRUE. GO PROCESS STATEMENT
;.
;:INPT BC RETN "INPUT"
;
;:I2   BV *            GET VARIABLE
;      SB              SWAP POINTERS
;      BE I4
; TYPE PROMPT
;
;      GL              READ INPUT LINE
;      BE I4           DID ANYTHING COME?
;      BR I3           NO, TRY AGAIN
;:I4   BC I5 ","       OPTIONAL COMMA
;:I5   JS EXPR         READ A NUMBER
;      SV              STORE INTO VARIABLE
;      RB              SWAP BACK
;      BC I6 ","       ANOTHER?
;      BR I2           YES IF COMMA
;:I6   BE *            OTHERWISE QUIT
;      NX
;.
;:RETN BC END "RETURN"
;
;      BE *
;      RS              RECOVER SAVED LINE
;      NX
;.
;:END  BC LIST "END"
;
;      BE *
;      WS
;.
;:LIST BC RUN "LIST"
;
;      BE L2
;:L1   PC "@^@^@^@^J^@^" PUNCH LEADER
;
;      LS              LIST
;      PC "S^"         PUNCH X-OFF
;      NL
;      NX
;:L2   JS EXPR         GET A LINE NUMBER
;      BE L3
;      BR L1
;:L3   BC * ","        SEPARATED BY COMMAS
;      BR L2
;.
;:RUN  BC CLER "RUN"
;
;      J XEC
;.
;:CLER BC REM "CLEAR"
;
;      MT
;.
;:REM  BC DFLT "REM"
;
;      NX
;.
;:DFLT BV *            NO KEYWORD...
;      BC * "="        TRY FOR LET
;      J LET           IT'S A GOOD BET.
;.
;.  SUBROUTINES
;.
;:EXPR BC E0 "-"       TRY FOR UNARY MINUS
;      JS TERM         AHA
;      NE
;      BR E1
;:E0   BC E4 "+"       IGNORE UNARY PLUS
;:E4   JS TERM
;:E1   BC E2 "+"       TERMS SEPARATED BY PLUS
;      JS TERM
;      AD
;      BR E1
;:E2   BC E3 "-"       TERMS SEPARATED BY MINUS
;      JS TERM
;      SU
;      BR E1
;:E3   RT
;.
;:TERM JS FACT
;:T0   BC T1 "*"       FACTORS SEPARATED BY TIMES
;      JS FACT
;      MP
;      BR T0
;:T1   BC T2 "/"       FACTORS SEPARATED BY DIVIDE
;      JS  FACT
;      DV
;      BR T0
;:T2   RT
;.
;:FACT BC F0 "RND"     *RND FUNCTION*
;
;      LN 257*128      STACK POINTER FOR STORE
;
;      FV              THEN GET RNDM
;      LN 2345         R:=R*2345+6789
;
;      MP
;      LN 6789
;
;      AD
;      SV
;      LB 128          GET IT AGAIN
;      FV
;      DS
;      JS FUNC         GET ARGUMENT
;      BR F1
;:F0   BR F2           (SKIPPING)
;:F1   DS
;      SX 2            PUSH TOP INTO STACK
;      SX 4
;      SX 2
;      SX 3
;      SX 5
;      SX 3
;      DV              PERFORM MOD FUNCTION
;      MP
;      SU
;      DS              PERFORM ABS FUNCTION
;      LB 6
;      LN 0
;
;      CP              (SKIP IF + OR 0)
;      NE
;      RT
;:F2   BC F3 "USR"     *USR FUNCTION*
;
;      BC * "("        3 ARGUMENTS POSSIBLE
;      JS EXPR         ONE REQUIRED
;      JS ARG
;      JS ARG
;      BC * ")"
;      US              GO DO IT
;      RT
;:F3   BV F4           VARIABLE?
;      FV              YES.  GET IT
;      RT
;:F4   BN F5           NUMBER?
;      RT              GOT IT.
;:F5   BC * "("        OTHERWISE MUST BE (EXPR)
;:F6   JS EXPR
;      BC * ")"
;      RT
;.
;:ARG  BC A0 ","        COMMA?
;      J  EXPR          YES, GET EXPRESSION
;:A0   DS               NO, DUPLICATE STACK TOP
;      RT
;.
;:FUNC BC * "("
;      BR F6
;      RT
;.
;:RELO BC R0 "="        CONVERT RELATION OPERATORS
;      LB 2             TO CODE BYTE ON STACK
;      RT               =
;:R0   BC R4 "<"
;      BC R1 "="
;      LB 3             <=
;      RT
;:R1   BC R3 ">"
;      LB 5             <>
;      RT
;:R3   LB 1             <
;      RT
;:R4   BC * ">"
;      BC R5 "="
;      LB 6             >=
;      RT
;:R5   BC R6 "<"
;      LB 5             ><
;      RT
;:R6   LB 4             >
;      RT
;.
;    0000
